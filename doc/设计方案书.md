# 基于FPGA的SIFT拼接设计方案

- [基于FPGA的SIFT拼接设计方案](#基于fpga的sift拼接设计方案)
  - [处理步骤](#处理步骤)
  - [性能分析](#性能分析)
  - [参考文献](#参考文献)

## 处理步骤

1. 检测关键特征点，计算特征描述子
   1. 关键点
   2. 特征描述符
2. 匹配特征点，返回匹配结果
3. 计算计算视角变换矩阵（findHomography()）
4. 进行视角变换（warpPerspective()）
5. 图像融合


## 性能分析
通过运行软件原型（以1920x1080的为例），统计得到性能参数如下：

| w	| h | pixel | time | detectAndDescribe |matchKeypoints|
|---|---|---|---|---|---|
|1920|	1080|2073600|2.51|1.640625	|0.625

可见主要时间花在了detectAndDescribe。detectAndDescribe对应步骤1, 

![detectAndDescribe流程](https://img2018.cnblogs.com/blog/1471528/201903/1471528-20190330204125547-535493662.png)

FPGA性能估算

|w|h|pixel|"金字塔组数/OCTAVE"|总像素点|主频/MHz|time/ms|"detectAndDescribe|matchKeypoints|
|---|---|---|---|---|---|---|---|---|
|1920|1080|2073600|8.076815597|2764757.813|250|11.05903125|				



***

高斯函数的filter size $N=[(6\sigma+1)]$
![](./pic/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0.png)

关键技术：**卷积核分离**

高斯金字塔 $\longrightarrow$ 高斯差分金字塔 $\longrightarrow$ 

**建立高斯金字塔**
1. 对图像做高斯模糊
2. 对图像做降采样

在高斯金字塔中，每层图像都是该组初始图像（该组最底层的图像）用不同尺度高斯核做高斯卷积得到的。每组图像的初始图像是上一组图像某层（倒数第三层）进行**隔点采样**（以 2 为因子下采样）得到的，然后再通过高斯模糊得到该组其他层的图像。

**高斯差分金字塔的建立**

为什么使用LOG：$\sigma^2\nabla^2G$ 的极大极小值相比于梯度、Hessian 或 Harris 角点检测来说，可以提供更稳定的图像特性。
为什么使用DOG：LOG计算复杂，使用差分来近似微分。

高斯差分金字塔是在高斯金字塔的基础上操作的，其建立过程是：在高斯金字塔中的每组中相邻两层相减（下一层减上一层）就生成高斯差分金字塔.

**检测局部极值点**
![局部极值点](./pic/%E5%B1%80%E9%83%A8%E6%9E%81%E5%80%BC%E7%82%B9.png)



尺度空间总量 *S*
为了在每组中检测出 S 个尺度的极值点，则 DOG 图像金字塔每组需 S + 2 层图像，而 DOG 图像金字塔是由高斯图像金字塔相邻两层相减得到的，因此高斯图像金字塔每组需 S + 3 层图像，一般 S 会取值在 [3,5] 之间，Lowe 建议S 为 3。


**最初的最初 关于第一层的模糊**

除了第一组外，其他组的第一层是上一组提取倒数第三层图像然后再进行降采样。原因有二
   - 本组第一层图像的尺度因子与上一组的倒数第三层尺度因子是一致的，因此获取本组第一层图像的过程就不再需要根据原图再卷积了，而是可以直接降采样来得到本组的初始图像。
   - 保证每组之间和每层之间的尺度因子就都是连续的。
 

*知识补充 角点检测*
在局部小范围里，如果在各个方向上移动窗口，窗口内区域的灰度发生较大变化，就认为在窗口内遇到了角点；如果窗口在各个方向移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点。


**LOG和DOG**
LOG 全称为 Laplacian of Gaussian，即高斯拉普拉斯算子。DOG 全称为 Difference of Gaussian，即高斯差分。这两种方法是用来检测极值点（突变信息、边缘信息）的，其中 DOG 是用来近似 LOG 的。

待解决问题
如何找特征点？DoG





## 参考文献

[SIFT算法原理详解](https://www.cnblogs.com/Alliswell-WP/p/SIFT.html)
